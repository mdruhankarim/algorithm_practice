/*G. Абай және тазалау
time limit per test1 second
memory limit per test256 megabytes
Абайдың бөлмесінде басқарылатын робот пен шашылып жатқан n
 ойыншық бар. Абайдың анасы оған бөлмені тазалауды тапсырды, бірақ Абайдың өзі мұны істеуге ерінеді, сондықтан ол роботтың көмегімен барлық ойыншықтарды алып тастағысы келеді.

Бөлмені координаталық тор түрінде ұсынуға болады. Робот (0,0)
 нүктесінде, ал i
-шы ойыншық (xi,yi)
 нүктесінде тұрады. (0,0)
 нүктесінде ойыншықтар жоқ және бір нүктеде бір ойыншықтан артық емес екеніне кепілдік беріледі.

Басқару пультінде төмен ('D') және солға ('L') түймелері сынғандықтан, робот тек жоғары ('U') және оңға ('R') қозғала алады. Яғни, түймені бір рет басу арқылы робот (x,y)
 нүктесінен (x+1,y)
 нүктесіне немесе (x,y+1)
 нүктесіне ауыса алады. Абай барлық n
 ойыншықтарды (кез келген тәртіпте) жинағысы келеді және ол мұны ең аз басу арқылы жасағысы келеді. Егер бірнеше қолайлы басу тізбегі болса, Абай лексикографиялық тұрғыдан минималды жолды таңдағысы келеді.

Ұзындығы n
 болатын s
 жолы лексикографиялық жағынан ұзындығы n
 болатын t
 жолынан кіші, егер 1
-ден j−1
-ге дейінгі барлық i
 үшін si=ti
 және sj<tj
 болатындай 1≤j≤n
 табылса.

Input
Кірістердің бірінші жолында бір бүтін сан бар – n
 (1≤n≤1000)
 - ойыншықтар саны.

Келесі n
 жолдарда екі бүтін сан жазылады – xi
, yi
 (0≤xi,yi≤1000)
 – ойыншықтардың координаттары.

Output
Егер барлық n
 ойыншықтарды (0,0)
 нүктеден бастап кез-келген ретпен жинау мүмкін болмаса, "NO" шығарыңыз.

Әйтпесе, бірінші жолда "YES" шығарыңыз. Содан кейін екінші жолда 'R' және 'U' таңбаларынан тұратын ең қысқа жолды шығарыңыз. Барлық осындай жолдардың ішінен сіз лексикографиялық минимумды таңдауыңыз керек.

Examples
InputCopy
4
0 1
3 4
4 4
2 1
OutputCopy
YES
URRRUUUR
InputCopy
3
1 1
2 3
4 2
OutputCopy
NO

*/
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin>>n;
    vector<pair<int, int>> toys(n);
    for (int i=0;i<n;++i){
        cin>>toys[i].first>>toys[i].second;
    }
    sort(toys.begin(),toys.end());
    int currentX=0,currentY=0;
    string path;
    for(const auto &toy:toys){
        int targetX=toy.first;
        int targetY=toy.second;
        if (targetX<currentX || targetY<currentY){
            cout<<"NO"<<endl;
            return 0;
        }
        while(currentX<targetX){
            path+='R';
            currentX++;
        }
        while(currentY<targetY){
            path+='U';
            currentY++;
        }
    }
    cout<<"YES"<<endl;
    cout<<path<<endl;
    return 0;
}
